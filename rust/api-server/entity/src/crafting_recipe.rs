//! `SeaORM` Entity. Generated by sea-orm-codegen 0.12.15

use game_module::module_bindings;
use game_module::module_bindings::CraftingRecipeDesc;
use sea_orm::FromJsonQueryResult;
use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

use crate::{inventory::ItemType, shared::item_stack::ItemStack};

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, FromJsonQueryResult)]
pub struct ConsumedItemStack {
    pub item_id: i32,
    pub quantity: i64,
    pub item_type: ItemType,
    pub discovery_score: i64,
    pub consumption_chance: f32,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, FromJsonQueryResult)]
pub struct BuildingRequirement {
    pub building_type: i32,
    pub tier: i32,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, FromJsonQueryResult)]
pub struct LevelRequirement {
    pub skill_id: i32,
    pub level: i32,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, FromJsonQueryResult)]
pub struct ToolRequirement {
    pub tool_type: i32,
    pub level: i32,
    pub power: i32,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, FromJsonQueryResult)]
pub struct ExperienceStackF32 {
    pub skill_id: i32,
    pub quantity: f32,
}
#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "crafting_recipe")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: i32,
    pub name: String,
    pub time_requirement: f32,
    pub stamina_requirement: f32,
    pub tool_durability_lost: i32,
    #[sea_orm(column_type = "Json")]
    pub building_requirement: Option<BuildingRequirement>,
    #[sea_orm(column_type = "Json")]
    pub level_requirements: Vec<LevelRequirement>,
    #[sea_orm(column_type = "Json")]
    pub tool_requirements: Vec<ToolRequirement>,
    #[sea_orm(column_type = "Json")]
    pub consumed_item_stacks: Vec<ConsumedItemStack>,
    pub discovery_triggers: Vec<i32>,
    pub required_knowledges: Vec<i32>,
    pub required_claim_tech_id: i32,
    pub full_discovery_score: i32,
    #[sea_orm(column_type = "Json")]
    pub experience_per_progress: Vec<ExperienceStackF32>,
    pub allow_use_hands: bool,
    #[sea_orm(column_type = "Json")]
    pub crafted_item_stacks: Vec<ItemStack>,
    pub is_passive: bool,
    pub actions_required: i32,
    pub tool_mesh_index: i32,
    pub recipe_performance_id: i32,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}

impl From<module_bindings::BuildingRequirement> for BuildingRequirement {
    fn from(value: module_bindings::BuildingRequirement) -> Self {
        BuildingRequirement {
            building_type: value.building_type,
            tier: value.tier,
        }
    }
}
impl From<module_bindings::ToolRequirement> for ToolRequirement {
    fn from(value: module_bindings::ToolRequirement) -> Self {
        ToolRequirement {
            level: value.level,
            tool_type: value.tool_type,
            power: value.power,
        }
    }
}
impl From<module_bindings::LevelRequirement> for LevelRequirement {
    fn from(value: module_bindings::LevelRequirement) -> Self {
        LevelRequirement {
            level: value.level,
            skill_id: value.skill_id,
        }
    }
}

impl From<module_bindings::ExperienceStackF32> for ExperienceStackF32 {
    fn from(value: module_bindings::ExperienceStackF32) -> Self {
        ExperienceStackF32 {
            quantity: value.quantity,
            skill_id: value.skill_id,
        }
    }
}

impl From<module_bindings::InputItemStack> for ConsumedItemStack {
    fn from(value: module_bindings::InputItemStack) -> Self {
        ConsumedItemStack {
            quantity: value.quantity as i64,
            consumption_chance: value.consumption_chance,
            item_type: value.item_type.into(),
            discovery_score: value.discovery_score as i64,
            item_id: value.item_id,
        }
    }
}

impl From<CraftingRecipeDesc> for Model {
    fn from(value: CraftingRecipeDesc) -> Self {
        let mut building_requirement: Option<BuildingRequirement> = None;
        if let Some(building) = value.building_requirement {
            building_requirement = Some(building.into())
        }
        Model {
            id: value.id as i32,
            name: value.name,
            time_requirement: value.time_requirement,
            stamina_requirement: value.stamina_requirement,
            building_requirement: building_requirement,
            level_requirements: value
                .level_requirements
                .iter()
                .map(|x| x.clone().into())
                .collect(),
            tool_requirements: value
                .tool_requirements
                .iter()
                .map(|x| x.clone().into())
                .collect(),
            consumed_item_stacks: value
                .consumed_item_stacks
                .iter()
                .map(|x| x.clone().into())
                .collect(),
            discovery_triggers: value.discovery_triggers,
            required_knowledges: value.required_knowledges,
            required_claim_tech_id: value.required_claim_tech_id,
            full_discovery_score: value.full_discovery_score,
            experience_per_progress: value
                .experience_per_progress
                .iter()
                .map(|x| x.clone().into())
                .collect(),
            allow_use_hands: value.allow_use_hands,
            crafted_item_stacks: value
                .crafted_item_stacks
                .iter()
                .map(|x| x.clone().into())
                .collect(),
            is_passive: value.is_passive,
            actions_required: value.actions_required,
            tool_mesh_index: value.tool_mesh_index,
            recipe_performance_id: value.recipe_performance_id,
            tool_durability_lost: value.tool_durability_lost,
        }
    }
}
